//Do not edit! This file was generated by Unity-ROS MessageGeneration.
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Unity.Robotics.ROSTCPConnector.MessageGeneration;

namespace RosMessageTypes.Moveit
{
    public class MPlanningScene : Message
    {
        public const string RosMessageName = "moveit_msgs/PlanningScene";

        //  name of planning scene
        public string name;
        //  full robot state
        public MRobotState robot_state;
        //  The name of the robot model this scene is for
        public string robot_model_name;
        // additional frames for duplicating tf (with respect to the planning frame)
        public Geometry.MTransformStamped[] fixed_frame_transforms;
        // full allowed collision matrix
        public MAllowedCollisionMatrix allowed_collision_matrix;
        //  all link paddings
        public MLinkPadding[] link_padding;
        //  all link scales
        public MLinkScale[] link_scale;
        //  Attached objects, collision objects, even the octomap or collision map can have 
        //  colors associated to them. This array specifies them.
        public MObjectColor[] object_colors;
        //  the collision map
        public MPlanningSceneWorld world;
        //  Flag indicating whether this scene is to be interpreted as a diff with respect to some other scene
        public bool is_diff;

        public MPlanningScene()
        {
            this.name = "";
            this.robot_state = new MRobotState();
            this.robot_model_name = "";
            this.fixed_frame_transforms = new Geometry.MTransformStamped[0];
            this.allowed_collision_matrix = new MAllowedCollisionMatrix();
            this.link_padding = new MLinkPadding[0];
            this.link_scale = new MLinkScale[0];
            this.object_colors = new MObjectColor[0];
            this.world = new MPlanningSceneWorld();
            this.is_diff = false;
        }

        public MPlanningScene(string name, MRobotState robot_state, string robot_model_name, Geometry.MTransformStamped[] fixed_frame_transforms, MAllowedCollisionMatrix allowed_collision_matrix, MLinkPadding[] link_padding, MLinkScale[] link_scale, MObjectColor[] object_colors, MPlanningSceneWorld world, bool is_diff)
        {
            this.name = name;
            this.robot_state = robot_state;
            this.robot_model_name = robot_model_name;
            this.fixed_frame_transforms = fixed_frame_transforms;
            this.allowed_collision_matrix = allowed_collision_matrix;
            this.link_padding = link_padding;
            this.link_scale = link_scale;
            this.object_colors = object_colors;
            this.world = world;
            this.is_diff = is_diff;
        }
        public override List<byte[]> SerializationStatements()
        {
            var listOfSerializations = new List<byte[]>();
            listOfSerializations.Add(SerializeString(this.name));
            listOfSerializations.AddRange(robot_state.SerializationStatements());
            listOfSerializations.Add(SerializeString(this.robot_model_name));
            
            listOfSerializations.Add(BitConverter.GetBytes(fixed_frame_transforms.Length));
            foreach(var entry in fixed_frame_transforms)
                listOfSerializations.Add(entry.Serialize());
            listOfSerializations.AddRange(allowed_collision_matrix.SerializationStatements());
            
            listOfSerializations.Add(BitConverter.GetBytes(link_padding.Length));
            foreach(var entry in link_padding)
                listOfSerializations.Add(entry.Serialize());
            
            listOfSerializations.Add(BitConverter.GetBytes(link_scale.Length));
            foreach(var entry in link_scale)
                listOfSerializations.Add(entry.Serialize());
            
            listOfSerializations.Add(BitConverter.GetBytes(object_colors.Length));
            foreach(var entry in object_colors)
                listOfSerializations.Add(entry.Serialize());
            listOfSerializations.AddRange(world.SerializationStatements());
            listOfSerializations.Add(BitConverter.GetBytes(this.is_diff));

            return listOfSerializations;
        }

        public override int Deserialize(byte[] data, int offset)
        {
            var nameStringBytesLength = DeserializeLength(data, offset);
            offset += 4;
            this.name = DeserializeString(data, offset, nameStringBytesLength);
            offset += nameStringBytesLength;
            offset = this.robot_state.Deserialize(data, offset);
            var robot_model_nameStringBytesLength = DeserializeLength(data, offset);
            offset += 4;
            this.robot_model_name = DeserializeString(data, offset, robot_model_nameStringBytesLength);
            offset += robot_model_nameStringBytesLength;
            
            var fixed_frame_transformsArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.fixed_frame_transforms= new Geometry.MTransformStamped[fixed_frame_transformsArrayLength];
            for(var i = 0; i < fixed_frame_transformsArrayLength; i++)
            {
                this.fixed_frame_transforms[i] = new Geometry.MTransformStamped();
                offset = this.fixed_frame_transforms[i].Deserialize(data, offset);
            }
            offset = this.allowed_collision_matrix.Deserialize(data, offset);
            
            var link_paddingArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.link_padding= new MLinkPadding[link_paddingArrayLength];
            for(var i = 0; i < link_paddingArrayLength; i++)
            {
                this.link_padding[i] = new MLinkPadding();
                offset = this.link_padding[i].Deserialize(data, offset);
            }
            
            var link_scaleArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.link_scale= new MLinkScale[link_scaleArrayLength];
            for(var i = 0; i < link_scaleArrayLength; i++)
            {
                this.link_scale[i] = new MLinkScale();
                offset = this.link_scale[i].Deserialize(data, offset);
            }
            
            var object_colorsArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.object_colors= new MObjectColor[object_colorsArrayLength];
            for(var i = 0; i < object_colorsArrayLength; i++)
            {
                this.object_colors[i] = new MObjectColor();
                offset = this.object_colors[i].Deserialize(data, offset);
            }
            offset = this.world.Deserialize(data, offset);
            this.is_diff = BitConverter.ToBoolean(data, offset);
            offset += 1;

            return offset;
        }

        public override string ToString()
        {
            return "MPlanningScene: " +
            "\nname: " + name.ToString() +
            "\nrobot_state: " + robot_state.ToString() +
            "\nrobot_model_name: " + robot_model_name.ToString() +
            "\nfixed_frame_transforms: " + System.String.Join(", ", fixed_frame_transforms.ToList()) +
            "\nallowed_collision_matrix: " + allowed_collision_matrix.ToString() +
            "\nlink_padding: " + System.String.Join(", ", link_padding.ToList()) +
            "\nlink_scale: " + System.String.Join(", ", link_scale.ToList()) +
            "\nobject_colors: " + System.String.Join(", ", object_colors.ToList()) +
            "\nworld: " + world.ToString() +
            "\nis_diff: " + is_diff.ToString();
        }
    }
}
